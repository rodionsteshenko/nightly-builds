#!/usr/bin/env python3
"""
commit-msg - AI-assisted git commit message generator

Uses Claude CLI to generate conventional commit messages from staged changes.
"""

import subprocess
import sys
import argparse
import tempfile
import os

# Conventional commit types
COMMIT_TYPES = {
    'feat': 'A new feature',
    'fix': 'A bug fix',
    'docs': 'Documentation only changes',
    'style': 'Formatting, missing semi colons, etc; no code change',
    'refactor': 'Code change that neither fixes a bug nor adds a feature',
    'perf': 'Code change that improves performance',
    'test': 'Adding missing tests or correcting existing tests',
    'build': 'Changes to build system or external dependencies',
    'ci': 'Changes to CI configuration files and scripts',
    'chore': 'Other changes that dont modify src or test files',
    'revert': 'Reverts a previous commit'
}

def get_staged_diff():
    """Get the staged diff from git."""
    try:
        result = subprocess.run(
            ['git', 'diff', '--cached', '--stat'],
            capture_output=True, text=True, check=True
        )
        stat = result.stdout.strip()
        
        result = subprocess.run(
            ['git', 'diff', '--cached'],
            capture_output=True, text=True, check=True
        )
        diff = result.stdout.strip()
        
        return stat, diff
    except subprocess.CalledProcessError as e:
        print(f"Error getting git diff: {e.stderr}", file=sys.stderr)
        sys.exit(1)

def get_recent_commits(n=5):
    """Get recent commit messages for style context."""
    try:
        result = subprocess.run(
            ['git', 'log', f'-{n}', '--pretty=format:%s'],
            capture_output=True, text=True, check=True
        )
        return result.stdout.strip().split('\n') if result.stdout else []
    except subprocess.CalledProcessError:
        return []

def truncate_diff(diff, max_chars=8000):
    """Truncate diff if too long, keeping the most informative parts."""
    if len(diff) <= max_chars:
        return diff
    
    # Keep first half and last quarter
    first_part = diff[:max_chars // 2]
    last_part = diff[-max_chars // 4:]
    
    return f"{first_part}\n\n... (diff truncated - {len(diff)} chars total) ...\n\n{last_part}"

def generate_commit_message(stat, diff, scope=None, recent_commits=None):
    """Use Claude CLI to generate a commit message."""
    
    prompt = f"""Generate a conventional commit message for these staged changes.

Conventional commit format:
<type>(<optional-scope>): <description>

Types: {', '.join(COMMIT_TYPES.keys())}

RULES:
1. Use lowercase for type and description
2. No period at end
3. Keep description under 72 chars
4. Be specific but concise
5. Focus on WHAT changed, not HOW

{"Recent commits (for style context):" + chr(10) + chr(10).join(f"- {c}" for c in recent_commits) if recent_commits else ""}

STAGED CHANGES:

{stat}

DIFF:

{truncate_diff(diff)}

{"Use scope: " + scope if scope else "Infer scope from the files changed, or omit if unclear."}

Output ONLY the commit message, nothing else."""

    try:
        result = subprocess.run(
            ['claude', '-p', prompt],
            capture_output=True, text=True, timeout=60
        )
        if result.returncode != 0:
            print(f"Claude CLI error: {result.stderr}", file=sys.stderr)
            return None
        return result.stdout.strip()
    except subprocess.TimeoutExpired:
        print("Claude CLI timed out", file=sys.stderr)
        return None
    except FileNotFoundError:
        print("Claude CLI not found. Install with: npm install -g @anthropic-ai/claude-cli", file=sys.stderr)
        return None

def edit_message(message):
    """Open message in editor for user to modify."""
    editor = os.environ.get('EDITOR', os.environ.get('VISUAL', 'vim'))
    
    with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
        f.write(message)
        f.write('\n\n# Edit the commit message above. Lines starting with # are ignored.')
        f.write('\n# Save and close to continue, or clear all text to abort.')
        temp_path = f.name
    
    try:
        subprocess.run([editor, temp_path], check=True)
        with open(temp_path, 'r') as f:
            edited = f.read()
        
        # Remove comments and trailing whitespace
        lines = [l for l in edited.split('\n') if not l.startswith('#')]
        return '\n'.join(lines).strip()
    finally:
        os.unlink(temp_path)

def do_commit(message):
    """Execute git commit with the message."""
    try:
        result = subprocess.run(
            ['git', 'commit', '-m', message],
            capture_output=True, text=True
        )
        if result.returncode == 0:
            print(result.stdout)
            return True
        else:
            print(f"Commit failed: {result.stderr}", file=sys.stderr)
            return False
    except subprocess.CalledProcessError as e:
        print(f"Commit error: {e}", file=sys.stderr)
        return False

def main():
    parser = argparse.ArgumentParser(
        description='AI-assisted git commit message generator',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  commit-msg              Generate message, prompt for action
  commit-msg -y           Generate and commit without prompting
  commit-msg -s api       Force scope to "api"
  commit-msg --dry-run    Show message without committing
  commit-msg --type fix   Suggest a fix commit
'''
    )
    parser.add_argument('-y', '--yes', action='store_true',
                        help='Commit immediately without prompting')
    parser.add_argument('-s', '--scope', type=str,
                        help='Specify commit scope')
    parser.add_argument('-t', '--type', type=str, choices=COMMIT_TYPES.keys(),
                        help='Suggest commit type (hint, not forced)')
    parser.add_argument('--dry-run', action='store_true',
                        help='Show message without committing')
    parser.add_argument('--no-style', action='store_true',
                        help='Skip analyzing recent commits for style')
    
    args = parser.parse_args()
    
    # Check if in git repo
    try:
        subprocess.run(['git', 'rev-parse', '--git-dir'],
                       capture_output=True, check=True)
    except subprocess.CalledProcessError:
        print("Not in a git repository", file=sys.stderr)
        sys.exit(1)
    
    # Get staged changes
    stat, diff = get_staged_diff()
    
    if not diff:
        print("No staged changes. Use 'git add' first.", file=sys.stderr)
        sys.exit(1)
    
    print(f"üìÅ Staged changes:\n{stat}\n")
    
    # Get recent commits for style context
    recent = [] if args.no_style else get_recent_commits()
    
    # Generate message
    print("ü§ñ Generating commit message...")
    message = generate_commit_message(stat, diff, args.scope, recent)
    
    if not message:
        print("Failed to generate commit message", file=sys.stderr)
        sys.exit(1)
    
    # If type hint provided, prepend if not already that type
    if args.type and not message.startswith(args.type):
        # Try to replace the type
        for t in COMMIT_TYPES.keys():
            if message.startswith(t):
                message = args.type + message[len(t):]
                break
    
    print(f"\nüí¨ Suggested message:\n   {message}\n")
    
    if args.dry_run:
        return
    
    if args.yes:
        if do_commit(message):
            print("‚úÖ Committed!")
        sys.exit(0)
    
    # Interactive mode
    while True:
        choice = input("[a]ccept, [e]dit, [r]egenerate, [q]uit? ").strip().lower()
        
        if choice in ('a', 'accept', 'y', 'yes', ''):
            if do_commit(message):
                print("‚úÖ Committed!")
            break
        elif choice in ('e', 'edit'):
            message = edit_message(message)
            if not message:
                print("Aborted - empty message")
                break
            print(f"\nüí¨ Updated message:\n   {message}\n")
        elif choice in ('r', 'regenerate'):
            print("ü§ñ Regenerating...")
            message = generate_commit_message(stat, diff, args.scope, recent)
            if message:
                print(f"\nüí¨ New message:\n   {message}\n")
            else:
                print("Failed to regenerate")
        elif choice in ('q', 'quit', 'n', 'no'):
            print("Aborted")
            break
        else:
            print("Unknown option. Use a/e/r/q")

if __name__ == '__main__':
    main()
